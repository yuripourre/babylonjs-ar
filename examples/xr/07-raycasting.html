<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BabylonJS AR - CPU Raycasting Example</title>
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      background: #1a1a2e;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #info {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 13px;
      max-width: 350px;
      z-index: 100;
      line-height: 1.6;
    }

    #info h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
      font-weight: 600;
    }

    .instruction {
      padding: 10px;
      background: rgba(100, 200, 255, 0.2);
      border-left: 3px solid #64C8FF;
      border-radius: 4px;
      margin: 10px 0;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #hitMarker {
      position: fixed;
      width: 20px;
      height: 20px;
      border: 2px solid #4CAF50;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.3);
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 50;
      display: none;
    }

    #rayLine {
      position: fixed;
      pointer-events: none;
      z-index: 40;
      display: none;
    }

    #stats {
      margin-top: 15px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      font-size: 11px;
    }

    .stat {
      margin: 4px 0;
    }

    .hit-result {
      margin-top: 10px;
      padding: 10px;
      background: rgba(76, 175, 80, 0.2);
      border-left: 3px solid #4CAF50;
      border-radius: 4px;
      display: none;
    }

    .no-hit {
      margin-top: 10px;
      padding: 10px;
      background: rgba(255, 152, 0, 0.2);
      border-left: 3px solid #FF9800;
      border-radius: 4px;
      display: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="hitMarker"></div>
    <svg id="rayLine" width="100%" height="100%">
      <line id="line" x1="0" y1="0" x2="0" y2="0"
            stroke="rgba(100, 200, 255, 0.5)" stroke-width="2"/>
    </svg>
  </div>

  <div id="info">
    <h2>CPU Raycasting Demo</h2>
    <div class="instruction">
      Click anywhere on the screen to cast a ray and detect intersections
    </div>
    <div id="stats">
      <div class="stat"><strong>Planes:</strong> <span id="planeCount">0</span></div>
      <div class="stat"><strong>Points:</strong> <span id="pointCount">0</span></div>
      <div class="stat"><strong>Rays Cast:</strong> <span id="rayCount">0</span></div>
    </div>
    <div id="hitResult" class="hit-result"></div>
    <div id="noHit" class="no-hit">No intersection found</div>
  </div>

  <script type="module">
    import {
      Ray,
      RaycasterEngine,
      Vector3,
      Matrix4,
      Logger,
    } from '../../dist/babylonjs-ar.js';

    Logger.setLevel('INFO');

    const canvas = document.getElementById('canvas');
    const hitMarker = document.getElementById('hitMarker');
    const rayLine = document.getElementById('rayLine');
    const line = document.getElementById('line');
    const hitResultEl = document.getElementById('hitResult');
    const noHitEl = document.getElementById('noHit');
    const planeCountEl = document.getElementById('planeCount');
    const pointCountEl = document.getElementById('pointCount');
    const rayCountEl = document.getElementById('rayCount');

    let raycasterEngine = new RaycasterEngine();
    let mockPlanes = [];
    let mockPointCloud = [];
    let rayCount = 0;

    // Camera setup (simple perspective camera)
    let cameraPosition = new Vector3(0, 2, 5);
    let cameraRotation = 0;

    // Create view and projection matrices
    function getViewMatrix() {
      // Simple look-at matrix (looking at origin)
      const forward = new Vector3(0, -0.3, -1).normalize();
      const right = new Vector3(1, 0, 0);
      const up = right.cross(forward).normalize();

      // View matrix (simplified)
      return new Matrix4([
        right.x, up.x, -forward.x, 0,
        right.y, up.y, -forward.y, 0,
        right.z, up.z, -forward.z, 0,
        -right.dot(cameraPosition),
        -up.dot(cameraPosition),
        forward.dot(cameraPosition),
        1
      ]);
    }

    function getProjectionMatrix() {
      const fov = Math.PI / 3; // 60 degrees
      const aspect = canvas.width / canvas.height;
      const near = 0.1;
      const far = 100;

      return Matrix4.perspective(fov, aspect, near, far);
    }

    // Create mock scene with planes
    function createMockScene() {
      // Ground plane
      mockPlanes.push({
        id: 'ground',
        center: new Vector3(0, 0, 0),
        normal: new Vector3(0, 1, 0),
        width: 10,
        height: 10,
        confidence: 0.9,
        boundary: [
          new Vector3(-5, 0, -5),
          new Vector3(5, 0, -5),
          new Vector3(5, 0, 5),
          new Vector3(-5, 0, 5),
        ],
      });

      // Wall plane
      mockPlanes.push({
        id: 'wall',
        center: new Vector3(0, 2, -3),
        normal: new Vector3(0, 0, 1),
        width: 6,
        height: 4,
        confidence: 0.8,
        boundary: [
          new Vector3(-3, 0, -3),
          new Vector3(3, 0, -3),
          new Vector3(3, 4, -3),
          new Vector3(-3, 4, -3),
        ],
      });

      // Create mock point cloud (grid of points)
      for (let x = -3; x <= 3; x += 0.2) {
        for (let y = 0; y <= 3; y += 0.2) {
          for (let z = -3; z <= 0; z += 0.2) {
            mockPointCloud.push({ x, y, z });
          }
        }
      }

      planeCountEl.textContent = mockPlanes.length;
      pointCountEl.textContent = mockPointCloud.length;
    }

    // Handle mouse click
    canvas.addEventListener('click', async (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      rayCount++;
      rayCountEl.textContent = rayCount;

      // Show ray line
      rayLine.style.display = 'block';
      line.setAttribute('x1', x);
      line.setAttribute('y1', y);

      // Perform hit test
      try {
        const results = await raycasterEngine.performHitTest(
          {
            screenPosition: { x, y },
            planes: mockPlanes,
            pointCloud: mockPointCloud,
            maxDistance: 50,
            useXR: false, // Force CPU raycast
          },
          undefined, // No XR frame
          getViewMatrix(),
          getProjectionMatrix(),
          canvas.width,
          canvas.height
        );

        if (results.length > 0) {
          const hit = results[0];

          // Show hit marker
          hitMarker.style.left = x + 'px';
          hitMarker.style.top = y + 'px';
          hitMarker.style.display = 'block';

          // Extend ray line to hit point
          // (In a real 3D renderer, you'd project the 3D hit point to 2D)
          line.setAttribute('x2', x + (hit.distance * 20));
          line.setAttribute('y2', y + (hit.distance * 20));

          // Display hit information
          hitResultEl.innerHTML = `
            <strong>Hit Detected!</strong><br>
            <strong>Type:</strong> ${hit.hitType}<br>
            <strong>Distance:</strong> ${hit.distance.toFixed(2)}m<br>
            <strong>Position:</strong> (${hit.hitPoint.x.toFixed(2)}, ${hit.hitPoint.y.toFixed(2)}, ${hit.hitPoint.z.toFixed(2)})<br>
            <strong>Normal:</strong> (${hit.normal.x.toFixed(2)}, ${hit.normal.y.toFixed(2)}, ${hit.normal.z.toFixed(2)})<br>
            <strong>Confidence:</strong> ${(hit.confidence * 100).toFixed(0)}%
            ${hit.plane ? `<br><strong>Plane ID:</strong> ${hit.plane.id}` : ''}
          `;
          hitResultEl.style.display = 'block';
          noHitEl.style.display = 'none';

          console.log('Hit detected:', hit);

          // Hide after 2 seconds
          setTimeout(() => {
            hitMarker.style.display = 'none';
            rayLine.style.display = 'none';
          }, 2000);

        } else {
          // No hit
          line.setAttribute('x2', x);
          line.setAttribute('y2', y + 100);

          noHitEl.style.display = 'block';
          hitResultEl.style.display = 'none';
          hitMarker.style.display = 'none';

          console.log('No hit detected');

          setTimeout(() => {
            rayLine.style.display = 'none';
            noHitEl.style.display = 'none';
          }, 1000);
        }

      } catch (error) {
        console.error('Raycasting failed:', error);
        noHitEl.textContent = 'Error: ' + error.message;
        noHitEl.style.display = 'block';
        hitResultEl.style.display = 'none';
      }
    });

    // Set canvas size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Draw simple 3D scene visualization on canvas
    const ctx = canvas.getContext('2d');

    function drawScene() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(100, 200, 255, 0.2)';
      ctx.lineWidth = 1;

      for (let i = 0; i <= 10; i++) {
        // Horizontal lines
        ctx.beginPath();
        ctx.moveTo(0, (canvas.height / 10) * i);
        ctx.lineTo(canvas.width, (canvas.height / 10) * i);
        ctx.stroke();

        // Vertical lines
        ctx.beginPath();
        ctx.moveTo((canvas.width / 10) * i, 0);
        ctx.lineTo((canvas.width / 10) * i, canvas.height);
        ctx.stroke();
      }

      // Draw planes as rectangles
      ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
      ctx.fillStyle = 'rgba(100, 200, 255, 0.1)';
      ctx.lineWidth = 2;

      // Ground plane (bottom)
      ctx.fillRect(canvas.width * 0.1, canvas.height * 0.7,
                   canvas.width * 0.8, canvas.height * 0.2);
      ctx.strokeRect(canvas.width * 0.1, canvas.height * 0.7,
                     canvas.width * 0.8, canvas.height * 0.2);

      // Wall plane (middle)
      ctx.fillRect(canvas.width * 0.2, canvas.height * 0.3,
                   canvas.width * 0.6, canvas.height * 0.3);
      ctx.strokeRect(canvas.width * 0.2, canvas.height * 0.3,
                     canvas.width * 0.6, canvas.height * 0.3);

      // Draw title
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.font = '20px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Click to Cast Ray', canvas.width / 2, canvas.height - 30);
    }

    // Initialize
    createMockScene();
    drawScene();

    console.log('CPU Raycasting demo initialized');
    console.log('Mock planes:', mockPlanes);
    console.log('Point cloud size:', mockPointCloud.length);
  </script>
</body>
</html>
