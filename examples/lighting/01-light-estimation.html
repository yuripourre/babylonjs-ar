<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Light Estimation Demo - BabylonJS AR</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #ffffff;
      overflow: hidden;
    }

    #renderCanvas {
      width: 100%;
      height: 100vh;
      display: block;
      touch-action: none;
    }

    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 12px;
      min-width: 300px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    h2 {
      font-size: 18px;
      margin-bottom: 15px;
      color: #00d4ff;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .label {
      color: #888;
    }

    .value {
      color: #ffffff;
      font-weight: 600;
    }

    .light-viz {
      width: 100px;
      height: 100px;
      border-radius: 8px;
      margin: 15px auto;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s ease;
    }

    .color-temp {
      height: 30px;
      border-radius: 4px;
      margin: 10px 0;
    }

    .vector-display {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      font-size: 12px;
      font-family: 'Courier New', monospace;
    }

    .vector-component {
      background: rgba(255, 255, 255, 0.1);
      padding: 5px 10px;
      border-radius: 4px;
      flex: 1;
      text-align: center;
    }

    button {
      width: 100%;
      padding: 12px;
      margin-top: 15px;
      background: #00d4ff;
      color: #000;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #00b8e6;
    }

    button:active {
      transform: scale(0.98);
    }

    #status {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
    }

    .source-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .source-xr {
      background: #00ff88;
      color: #000;
    }

    .source-cpu {
      background: #ffaa00;
      color: #000;
    }

    .sh-viz {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin: 10px 0;
    }

    .sh-coeff {
      background: rgba(255, 255, 255, 0.05);
      padding: 5px;
      border-radius: 3px;
      font-size: 10px;
      text-align: center;
      font-family: 'Courier New', monospace;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="controls">
    <h2>ðŸŒŸ Light Estimation</h2>

    <div class="info-row">
      <span class="label">Ambient Intensity:</span>
      <span class="value" id="ambientIntensity">-</span>
    </div>

    <div class="light-viz" id="lightViz"></div>

    <div class="info-row">
      <span class="label">Color Temperature:</span>
      <span class="value" id="colorTemp">-</span>
    </div>

    <div class="color-temp" id="colorTempViz"></div>

    <div class="info-row">
      <span class="label">Primary Intensity:</span>
      <span class="value" id="primaryIntensity">-</span>
    </div>

    <div class="info-row">
      <span class="label">Light Direction:</span>
    </div>
    <div class="vector-display">
      <div class="vector-component">X: <span id="dirX">-</span></div>
      <div class="vector-component">Y: <span id="dirY">-</span></div>
      <div class="vector-component">Z: <span id="dirZ">-</span></div>
    </div>

    <div class="info-row">
      <span class="label">Source:</span>
      <span class="value" id="source">
        <span class="source-badge source-cpu">CPU Fallback</span>
      </span>
    </div>

    <div class="info-row">
      <span class="label">Confidence:</span>
      <span class="value" id="confidence">-</span>
    </div>

    <button id="startBtn">Start Camera</button>
  </div>

  <div id="status">Initializing...</div>

  <script type="module">
    // Note: In production, this would import from the built library
    // For now, we'll demonstrate the concept with Babylon.js

    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);

    // Status updates
    const status = document.getElementById('status');
    function updateStatus(msg) {
      status.textContent = msg;
      console.log('[Light Estimation]', msg);
    }

    // Create the scene
    const createScene = () => {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.1, 1);

      // Camera
      const camera = new BABYLON.ArcRotateCamera(
        'camera',
        -Math.PI / 2,
        Math.PI / 3,
        10,
        BABYLON.Vector3.Zero(),
        scene
      );
      camera.attachControl(canvas, true);
      camera.lowerRadiusLimit = 5;
      camera.upperRadiusLimit = 20;

      // Create a few objects to demonstrate lighting
      const sphere = BABYLON.MeshBuilder.CreateSphere('sphere', { diameter: 2 }, scene);
      sphere.position.y = 1;

      const box = BABYLON.MeshBuilder.CreateBox('box', { size: 1.5 }, scene);
      box.position.set(-3, 0.75, 0);

      const cylinder = BABYLON.MeshBuilder.CreateCylinder('cylinder', {
        height: 2,
        diameter: 1.5
      }, scene);
      cylinder.position.set(3, 1, 0);

      // Ground plane
      const ground = BABYLON.MeshBuilder.CreateGround('ground', {
        width: 20,
        height: 20
      }, scene);

      // Apply PBR materials
      const pbr = new BABYLON.PBRMetallicRoughnessMaterial('pbr', scene);
      pbr.baseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
      pbr.metallic = 0.5;
      pbr.roughness = 0.4;

      sphere.material = pbr;
      box.material = pbr.clone('pbr-box');
      box.material.baseColor = new BABYLON.Color3(1, 0.3, 0.3);
      cylinder.material = pbr.clone('pbr-cylinder');
      cylinder.material.baseColor = new BABYLON.Color3(0.3, 0.5, 1);

      ground.material = pbr.clone('pbr-ground');
      ground.material.baseColor = new BABYLON.Color3(0.5, 0.5, 0.5);

      // Lights (will be controlled by light estimation)
      const hemiLight = new BABYLON.HemisphericLight(
        'ar-ambient-light',
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      hemiLight.intensity = 0.5;

      const dirLight = new BABYLON.DirectionalLight(
        'ar-primary-light',
        new BABYLON.Vector3(0, -1, 0),
        scene
      );
      dirLight.intensity = 1;

      updateStatus('Scene ready');
      return scene;
    };

    const scene = createScene();

    // Simulated light estimation (in production, this would use real camera)
    let simulatedLightAngle = 0;
    let simulatedIntensity = 0.7;
    let simulatedColorTemp = 6500;

    function simulateLightEstimate() {
      // Simulate changing lighting conditions
      simulatedLightAngle += 0.01;
      simulatedIntensity = 0.5 + Math.sin(simulatedLightAngle * 0.5) * 0.3;
      simulatedColorTemp = 5000 + Math.sin(simulatedLightAngle * 0.3) * 1500;

      const direction = {
        x: Math.sin(simulatedLightAngle),
        y: 0.5 + Math.cos(simulatedLightAngle * 0.5) * 0.3,
        z: Math.cos(simulatedLightAngle)
      };

      // Normalize
      const len = Math.sqrt(direction.x**2 + direction.y**2 + direction.z**2);
      direction.x /= len;
      direction.y /= len;
      direction.z /= len;

      // Convert color temperature to RGB
      const rgb = colorTempToRGB(simulatedColorTemp);

      return {
        ambientIntensity: simulatedIntensity,
        primaryDirection: direction,
        primaryIntensity: simulatedIntensity * 1.2,
        primaryColor: rgb,
        colorTemperature: simulatedColorTemp,
        confidence: 0.85,
        source: 'cpu-fallback',
        timestamp: Date.now()
      };
    }

    function colorTempToRGB(kelvin) {
      const temp = kelvin / 100;
      let r, g, b;

      if (temp <= 66) {
        r = 255;
      } else {
        r = temp - 60;
        r = 329.698727446 * Math.pow(r, -0.1332047592);
        r = Math.max(0, Math.min(255, r));
      }

      if (temp <= 66) {
        g = temp;
        g = 99.4708025861 * Math.log(g) - 161.1195681661;
      } else {
        g = temp - 60;
        g = 288.1221695283 * Math.pow(g, -0.0755148492);
      }
      g = Math.max(0, Math.min(255, g));

      if (temp >= 66) {
        b = 255;
      } else if (temp <= 19) {
        b = 0;
      } else {
        b = temp - 10;
        b = 138.5177312231 * Math.log(b) - 305.0447927307;
        b = Math.max(0, Math.min(255, b));
      }

      return {
        r: r / 255,
        g: g / 255,
        b: b / 255
      };
    }

    // Apply light estimate to scene
    function applyLightEstimate(estimate) {
      const hemiLight = scene.getLightByName('ar-ambient-light');
      const dirLight = scene.getLightByName('ar-primary-light');

      if (hemiLight) {
        hemiLight.intensity = estimate.ambientIntensity;
        hemiLight.diffuse = new BABYLON.Color3(
          estimate.primaryColor.r * 0.8 + 0.2,
          estimate.primaryColor.g * 0.8 + 0.2,
          estimate.primaryColor.b * 0.9 + 0.1
        );
      }

      if (dirLight) {
        dirLight.direction = new BABYLON.Vector3(
          -estimate.primaryDirection.x,
          -estimate.primaryDirection.y,
          -estimate.primaryDirection.z
        );
        dirLight.intensity = estimate.primaryIntensity * 2;
        dirLight.diffuse = new BABYLON.Color3(
          estimate.primaryColor.r,
          estimate.primaryColor.g,
          estimate.primaryColor.b
        );
      }

      // Update UI
      updateUI(estimate);
    }

    function updateUI(estimate) {
      document.getElementById('ambientIntensity').textContent =
        (estimate.ambientIntensity * 100).toFixed(1) + '%';

      document.getElementById('primaryIntensity').textContent =
        (estimate.primaryIntensity * 100).toFixed(1) + '%';

      document.getElementById('colorTemp').textContent =
        Math.round(estimate.colorTemperature) + 'K';

      document.getElementById('dirX').textContent = estimate.primaryDirection.x.toFixed(2);
      document.getElementById('dirY').textContent = estimate.primaryDirection.y.toFixed(2);
      document.getElementById('dirZ').textContent = estimate.primaryDirection.z.toFixed(2);

      document.getElementById('confidence').textContent =
        (estimate.confidence * 100).toFixed(1) + '%';

      // Update light visualization
      const lightViz = document.getElementById('lightViz');
      const rgb = estimate.primaryColor;
      const brightness = estimate.ambientIntensity;
      lightViz.style.backgroundColor = `rgb(${rgb.r * brightness * 255}, ${rgb.g * brightness * 255}, ${rgb.b * brightness * 255})`;

      // Update color temperature visualization
      const tempViz = document.getElementById('colorTempViz');
      tempViz.style.backgroundColor = `rgb(${rgb.r * 255}, ${rgb.g * 255}, ${rgb.b * 255})`;

      // Update source badge
      const sourceBadge = document.getElementById('source').querySelector('.source-badge');
      if (estimate.source === 'xr-native') {
        sourceBadge.className = 'source-badge source-xr';
        sourceBadge.textContent = 'XR Native';
      } else {
        sourceBadge.className = 'source-badge source-cpu';
        sourceBadge.textContent = 'CPU Fallback';
      }
    }

    // Start button
    let isRunning = false;
    document.getElementById('startBtn').addEventListener('click', () => {
      isRunning = !isRunning;
      const btn = document.getElementById('startBtn');

      if (isRunning) {
        btn.textContent = 'Stop';
        updateStatus('Light estimation running');
      } else {
        btn.textContent = 'Start Camera';
        updateStatus('Paused');
      }
    });

    // Render loop
    engine.runRenderLoop(() => {
      if (isRunning) {
        // Simulate light estimation
        const estimate = simulateLightEstimate();
        applyLightEstimate(estimate);
      }

      scene.render();
    });

    // Handle resize
    window.addEventListener('resize', () => {
      engine.resize();
    });

    updateStatus('Ready - Click "Start Camera" to begin');
  </script>
</body>
</html>
