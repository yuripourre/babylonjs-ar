<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Babylon.js AR - Complete Hybrid Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #renderCanvas {
      width: 100%;
      height: 100vh;
      touch-action: none;
    }
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 10;
      max-width: 300px;
    }
    #stats {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.9;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    button.active {
      background: #2196F3;
    }
    .status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status.active {
      background: #4CAF50;
    }
    .status.inactive {
      background: #f44336;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="overlay">
    <h3 style="margin: 0 0 10px 0;">ðŸš€ Complete AR Demo</h3>
    <div><span class="status" id="markerStatus"></span>Marker Tracking</div>
    <div><span class="status" id="planeStatus"></span>Plane Detection</div>
    <div><span class="status" id="depthStatus"></span>Depth Estimation</div>
    <div><span class="status" id="featureStatus"></span>Feature Tracking</div>
    <div id="stats"></div>
  </div>

  <div id="controls">
    <button id="toggleMarkers">Toggle Markers</button>
    <button id="togglePlanes">Toggle Planes</button>
    <button id="toggleDepth">Toggle Depth</button>
    <button id="resetTracking">Reset All</button>
  </div>

  <script type="importmap">
  {
    "imports": {
      "@babylonjs/core": "https://cdn.jsdelivr.net/npm/@babylonjs/core@7.0.0/index.js"
    }
  }
  </script>

  <script type="module">
    import * as BABYLON from '@babylonjs/core';
    import { BabylonAR } from '../dist/adapters/babylon/babylon-ar.js';

    console.log('[Demo] Starting Complete AR Demo');

    // State
    let markersEnabled = true;
    let planesEnabled = true;
    let depthEnabled = false; // Disabled by default (requires stereo)
    let markerCount = 0;
    let planeCount = 0;
    let featureCount = 0;

    // Create AR with all features enabled
    const ar = new BabylonAR({
      preset: 'desktop',
      enableMarkers: true,
      enablePlanes: true,
      enableDepth: false, // Enable when stereo camera available
      onReady: () => {
        console.log('[Demo] AR Ready');
        updateStatus();
      },
      onMarkerDetected: (marker, anchor) => {
        markerCount++;
        console.log(`[Demo] Marker ${marker.id} detected`);

        // Create a different 3D object for each marker
        const objects = [
          createCube,
          createSphere,
          createCylinder,
          createTorus,
        ];

        const createFunc = objects[marker.id % objects.length];
        const mesh = createFunc(ar.scene, marker.id);
        anchor.addChild(mesh);

        // Add label
        const label = createLabel(ar.scene, `Marker ${marker.id}`);
        label.position.y = 0.15;
        anchor.addChild(label);

        updateStats();
      },
      onPlaneDetected: (plane, anchor) => {
        planeCount++;
        console.log(`[Demo] Plane ${plane.id} detected (${plane.orientation})`);

        // Visual plane mesh is created automatically by BabylonAR
        // Let's add an interactive element

        if (plane.orientation === 'horizontal') {
          // Place a floating cube above horizontal planes
          const cube = BABYLON.MeshBuilder.CreateBox('planeCube', { size: 0.05 }, ar.scene);
          const material = new BABYLON.StandardMaterial('planeMat', ar.scene);
          material.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
          material.emissiveColor = new BABYLON.Color3(0.2, 0.1, 0);
          cube.material = material;
          cube.position.y = 0.1; // Float above plane
          anchor.addChild(cube);

          // Animate
          ar.scene.registerBeforeRender(() => {
            cube.rotation.y += 0.02;
          });
        }

        updateStats();
      },
    });

    async function init() {
      try {
        await ar.start();
        console.log('[Demo] AR Started');

        // Add ambient lighting
        const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), ar.scene);
        light.intensity = 0.7;

        setupControls();
        startStatsUpdate();

      } catch (error) {
        console.error('[Demo] Initialization error:', error);
        document.getElementById('overlay').innerHTML = `
          <h3>Error</h3>
          <p>${error.message}</p>
          <p>Please allow camera access and ensure WebGPU is supported.</p>
        `;
      }
    }

    function createCube(scene, id) {
      const cube = BABYLON.MeshBuilder.CreateBox(`cube_${id}`, { size: 0.1 }, scene);
      const material = new BABYLON.StandardMaterial(`cubeMat_${id}`, scene);
      material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
      cube.material = material;
      cube.position.y = 0.05;

      // Animate
      scene.registerBeforeRender(() => {
        cube.rotation.y += 0.01;
        cube.rotation.x += 0.005;
      });

      return cube;
    }

    function createSphere(scene, id) {
      const sphere = BABYLON.MeshBuilder.CreateSphere(`sphere_${id}`, { diameter: 0.1 }, scene);
      const material = new BABYLON.StandardMaterial(`sphereMat_${id}`, scene);
      material.diffuseColor = new BABYLON.Color3(0, 0.7, 1);
      material.emissiveColor = new BABYLON.Color3(0, 0.1, 0.2);
      sphere.material = material;
      sphere.position.y = 0.05;

      // Pulsing animation
      let scale = 1;
      let growing = true;
      scene.registerBeforeRender(() => {
        if (growing) {
          scale += 0.005;
          if (scale > 1.2) growing = false;
        } else {
          scale -= 0.005;
          if (scale < 0.8) growing = true;
        }
        sphere.scaling = new BABYLON.Vector3(scale, scale, scale);
      });

      return sphere;
    }

    function createCylinder(scene, id) {
      const cylinder = BABYLON.MeshBuilder.CreateCylinder(`cylinder_${id}`, {
        height: 0.1,
        diameter: 0.08
      }, scene);
      const material = new BABYLON.StandardMaterial(`cylinderMat_${id}`, scene);
      material.diffuseColor = new BABYLON.Color3(1, 0, 1);
      cylinder.material = material;
      cylinder.position.y = 0.05;

      // Spinning animation
      scene.registerBeforeRender(() => {
        cylinder.rotation.y += 0.02;
      });

      return cylinder;
    }

    function createTorus(scene, id) {
      const torus = BABYLON.MeshBuilder.CreateTorus(`torus_${id}`, {
        diameter: 0.1,
        thickness: 0.02
      }, scene);
      const material = new BABYLON.StandardMaterial(`torusMat_${id}`, scene);
      material.diffuseColor = new BABYLON.Color3(1, 1, 0);
      torus.material = material;
      torus.position.y = 0.05;

      // Complex rotation
      scene.registerBeforeRender(() => {
        torus.rotation.x += 0.01;
        torus.rotation.z += 0.015;
      });

      return torus;
    }

    function createLabel(scene, text) {
      // Simple text sprite placeholder
      const plane = BABYLON.MeshBuilder.CreatePlane('label', { size: 0.05 }, scene);
      const material = new BABYLON.StandardMaterial('labelMat', scene);
      material.diffuseColor = new BABYLON.Color3(1, 1, 1);
      material.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
      plane.material = material;
      plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      return plane;
    }

    function setupControls() {
      document.getElementById('toggleMarkers').addEventListener('click', () => {
        markersEnabled = !markersEnabled;
        document.getElementById('toggleMarkers').classList.toggle('active', markersEnabled);
        console.log(`[Demo] Markers ${markersEnabled ? 'enabled' : 'disabled'}`);
        updateStatus();
      });

      document.getElementById('togglePlanes').addEventListener('click', () => {
        planesEnabled = !planesEnabled;
        document.getElementById('togglePlanes').classList.toggle('active', planesEnabled);

        // Toggle plane visibility
        const planeAnchors = ar.getAllPlaneAnchors();
        planeAnchors.forEach(anchor => {
          anchor.setEnabled(planesEnabled);
        });

        console.log(`[Demo] Planes ${planesEnabled ? 'enabled' : 'disabled'}`);
        updateStatus();
      });

      document.getElementById('toggleDepth').addEventListener('click', () => {
        depthEnabled = !depthEnabled;
        document.getElementById('toggleDepth').classList.toggle('active', depthEnabled);
        console.log(`[Demo] Depth ${depthEnabled ? 'enabled' : 'disabled'} (requires stereo)`);
        updateStatus();
      });

      document.getElementById('resetTracking').addEventListener('click', () => {
        // Clear all anchors
        const markerAnchors = ar.getAllMarkerAnchors();
        markerAnchors.forEach(anchor => {
          anchor.getChildren().forEach(child => child.dispose());
        });

        const planeAnchors = ar.getAllPlaneAnchors();
        planeAnchors.forEach(anchor => {
          anchor.getChildren().forEach(child => child.dispose());
        });

        markerCount = 0;
        planeCount = 0;
        featureCount = 0;

        console.log('[Demo] Tracking reset');
        updateStats();
      });
    }

    function updateStatus() {
      document.getElementById('markerStatus').className = `status ${markersEnabled ? 'active' : 'inactive'}`;
      document.getElementById('planeStatus').className = `status ${planesEnabled ? 'active' : 'inactive'}`;
      document.getElementById('depthStatus').className = `status ${depthEnabled ? 'active' : 'inactive'}`;
      document.getElementById('featureStatus').className = 'status inactive'; // Not yet visible
    }

    function updateStats() {
      document.getElementById('stats').innerHTML = `
        <div>ðŸ“¦ Markers: ${markerCount}</div>
        <div>ðŸ”· Planes: ${planeCount}</div>
        <div>ðŸŽ¯ Features: ${featureCount}</div>
        <div>ðŸ“Š FPS: ${Math.round(ar.scene.getEngine().getFps())}</div>
      `;
    }

    function startStatsUpdate() {
      setInterval(updateStats, 1000);
    }

    // Start
    init();

    // Handle window resize
    window.addEventListener('resize', () => {
      ar.resize();
    });
  </script>

  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; color: white; font-size: 12px; max-width: 250px; z-index: 10;">
    <h4 style="margin: 0 0 10px 0;">ðŸ“– Instructions</h4>
    <p>1. Allow camera access</p>
    <p>2. Show ArUco markers to camera</p>
    <p>3. Point at flat surfaces for plane detection</p>
    <p>4. Toggle features with buttons below</p>
    <p>Download markers: <a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" style="color: #4CAF50;">ArUco Markers</a></p>
  </div>
</body>
</html>
